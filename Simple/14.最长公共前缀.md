### 14.最长公共前缀

###### 思路：

将字符串数组的第一个字符串用作参考，和剩余所有字符串进行比较。

将第一个字符串的第一个字符和其他所有字符串的第一个字符进行比较

若全部相同，然后将第一个字符串的第二个字符和其他所有字符串的第二个字符比较

...

最短的字符串的第i个字符已经不存在时，结束比较，因为求的是公共前缀

在任意一次比较中存在不相同，结束比较

定义一个空字符串承接比较出来的最长公共前缀，最后返回该字符串



###### 更优：

纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。

复杂度分析：

- 时间复杂度：O(mn)O(mn)O(mn)，其中 mmm 是字符串数组中的字符串的平均长度，nnn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。

- 空间复杂度：O(1)O(1)O(1)。使用的额外空间复杂度为常数。


```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        int length = strs[0].length();
        int count = strs.length;
        for (int i = 0; i < length; i++) {
            char c = strs[0].charAt(i);
            for (int j = 1; j < count; j++) {
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                }
            }
        }
        return strs[0];
    }
}
```

其实，和我的思路是一样的



还有一种横向扫描：依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。

就是1和2先确认两者的最长公共前缀，然后最长公共前缀再依次往后比较，并更新最长公共前缀。例，1和2比，最长公共前缀和3，更新最长公共前缀，再和4比...若当最长公共前缀已经是空字符串时，就可以返回了，因为再继续比较，它依旧是空的。